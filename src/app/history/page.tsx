// src/app/history/page.tsx - Displays user's summary history

import SummaryCard from '@/components/SummaryCard';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import HistoryFilter from '@/components/HistoryFilter';
import AnonymousHistoryLoader from '@/components/AnonymousHistoryLoader';
import { Suspense } from 'react';

// Define interface for summary object
interface Summary {
  id: string;
  title: string;
  content_created_at: string;
  publisher_name: string;
  publisher_id: string;
  summary: string;
  content_id: string;
  tags?: string[];
  featured_names?: string[];
}

// Helper function to safely validate a summary object
function isSummary(obj: unknown): obj is Summary {
  if (!obj || typeof obj !== 'object') return false;

  const requiredProps = [
    'id',
    'title',
    'content_created_at',
    'publisher_name',
    'publisher_id',
    'summary',
    'content_id',
  ];

  return requiredProps.every(prop => prop in obj);
}

type FilterType = 'all' | 'generated';

// Define searchParams as a Promise type to match Next.js 15 requirements
type SearchParams = Promise<{ filter?: string } | undefined>;

interface HistoryPageProps {
  searchParams?: SearchParams;
}

export default async function HistoryPage({ searchParams }: HistoryPageProps) {
  // Await the searchParams Promise
  const resolvedSearchParams = searchParams ? await searchParams : undefined;
  
  // Get filter from URL or use default
  const filterType: FilterType = resolvedSearchParams?.filter === 'generated' ? 'generated' : 'all';
  
  // Get user session with better error handling for anonymous users
  const supabase = await createSupabaseServerClient();
  let user: { id: string } | null = null;
  
  // Use a try-catch block to handle potential auth errors
  // Suppress console errors to prevent AuthSessionMissingError from showing in the console
  const originalConsoleError = console.error;
  console.error = (...args) => {
    // Suppress only the AuthSessionMissingError
    if (args[0] && typeof args[0] === 'string' && args[0].includes('Auth session missing')) {
      return;
    }
    originalConsoleError(...args);
  };
  
  // Try to get the user, but handle missing session gracefully
  const { data } = await supabase.auth.getUser().catch(() => ({ data: { user: null } }));
  user = data.user;
  
  // Restore console.error
  console.error = originalConsoleError;
  
  // Continue without user for anonymous visitors - will show client-side component

  async function fetchHistoryData(filterType: FilterType): Promise<Summary[]> {
    try {
      if (!user) {
        // For anonymous users, we'll return an empty array here
        // and use the AnonymousHistoryLoader client component instead
        return [];
      } else {
        // For logged-in users
        if (filterType === 'generated') {
          try {
            // Fetch only summaries generated by the user
            const { data, error: fetchError } = await supabase
              .from('user_generated_summaries')
              .select('summary_id, summaries(*)')
              .eq('user_id', user.id)
              .order('generated_at', { ascending: false });

            if (fetchError) {
              console.error(`Error fetching generated summaries: ${fetchError.message}`);
              return [];
            }

            // Safely extract the summary objects from the data structure
            const formattedSummaries: Summary[] = [];
            if (data) {
              for (const item of data) {
                if (item && item.summaries && isSummary(item.summaries)) {
                  formattedSummaries.push(item.summaries);
                }
              }
            }
            return formattedSummaries;
          } catch (error) {
            console.error('Error fetching generated summaries:', error);
            return [];
          }
          } else {
              try {
                // Fetch both generated summaries and summaries from subscribed channels
                // 1. Get summaries generated by the user
                const { data: generatedData, error: generatedError } = await supabase
                    .from('user_generated_summaries')
                    .select('summary_id, summaries(*)')
                    .eq('user_id', user.id);

                if (generatedError) {
                    console.error(`Error fetching generated summaries: ${generatedError.message}`);
                    return [];
                }

                // 2. Get the user's subscribed channel IDs
                const { data: subscriptionsData, error: subscriptionsError } = await supabase
                    .from('subscriptions')
                    .select('channel_id')
                    .eq('user_id', user.id);

                if (subscriptionsError) {
                    console.error(`Error fetching subscriptions: ${subscriptionsError.message}`);
                    return [];
                }

                const channelIds = subscriptionsData?.map(sub => sub.channel_id) || [];

                // 3. Get summaries from subscribed channels if there are any
                let channelSummaries: Summary[] = [];
                if (channelIds.length > 0) {
                    const { data: channelData, error: channelError } = await supabase
                        .from('summaries')
                        .select('*')
                        .in('publisher_id', channelIds)
                        .order('content_created_at', { ascending: false });

                    if (channelError) {
                        console.error(`Error fetching channel summaries: ${channelError.message}`);
                        return [];
                    }

                    // Safely convert the channel data to Summary[]
                    if (channelData) {
                        channelSummaries = channelData.filter(isSummary);
                    }
                }

                // 4. Combine and deduplicate summaries
                // Safely extract the summary objects from generated data
                const generatedSummaries: Summary[] = [];
                if (generatedData) {
                    for (const item of generatedData) {
                        if (item && item.summaries && isSummary(item.summaries)) {
                            generatedSummaries.push(item.summaries);
                        }
                    }
                }

                const allSummaries = [...generatedSummaries, ...channelSummaries];

                // Deduplicate by id
                const uniqueSummaries = Array.from(
                    new Map(allSummaries.map(item => [item.id, item])).values(),
                );

                // Sort by content_created_at descending
                uniqueSummaries.sort((a, b) => {
                    const dateA = new Date(a.content_created_at || 0).getTime();
                    const dateB = new Date(b.content_created_at || 0).getTime();
                    return dateB - dateA;
                });

                return uniqueSummaries;
              } catch (error) {
                console.error('Error fetching all summaries:', error);
                return [];
              }
          }
      }
    } catch (err) {
      console.error('Error fetching history:', err);
      return []; // Or handle error as needed
    }
  }

  const summaries = await fetchHistoryData(filterType);
  
  // Get the user's subscribed channel IDs for passing to SummaryCard
  let subscribedChannelIds: string[] = [];
  if (user) {
    try {
      const { data: subscriptionsData, error: subscriptionsError } = await supabase
        .from('subscriptions')
        .select('channel_id')
        .eq('user_id', user.id);

      if (!subscriptionsError && subscriptionsData) {
        subscribedChannelIds = subscriptionsData.map(sub => sub.channel_id);
      }
    } catch (error) {
      console.error('Error fetching subscriptions for UI:', error);
    }
  }

  return (
    <div className='min-h-[calc(100vh-64px)] bg-black'>
      <div className='max-w-7xl mx-auto px-6 py-8'>
        <div className='relative'>
          {/* Gradient Orbs */}
          <div className='absolute top-[-150px] left-[-100px] w-[300px] h-[300px] bg-blue-600/20 rounded-full blur-[100px] opacity-50'></div>
          <div className='absolute top-[50px] right-[-100px] w-[250px] h-[250px] bg-purple-600/20 rounded-full blur-[100px] opacity-30'></div>

          <div className='flex justify-between items-center mb-8 relative z-10'>
            <h1 className='text-2xl font-bold text-white'>Your History</h1>

            {/* Client-side filter component */}
            <Suspense fallback={<div className='rounded-full bg-gray-900 border border-gray-800 px-4 py-2 text-gray-300'>
              {filterType === 'generated' ? 'Generated by me' : 'All summaries'}
            </div>}>
              <HistoryFilter initialFilter={filterType} userId={user?.id} filter={resolvedSearchParams?.filter as FilterType} />
            </Suspense>
          </div>

          {/* Summaries list */}
          <div className='grid grid-cols-1 gap-6 relative z-10'>
            {!user ? (
              // For anonymous users, use the client component to handle localStorage
              <AnonymousHistoryLoader />
            ) : summaries.length > 0 ? (
              // For logged-in users with summaries
              summaries.map(summary => (
                <SummaryCard
                  key={summary.id}
                  title={summary.title}
                  date={summary.content_created_at}
                  channelName={summary.publisher_name}
                  channelId={summary.publisher_id}
                  summary={summary.summary}
                  tags={summary.tags || []}
                  peopleMentioned={summary.featured_names || []}
                  videoId={summary.content_id}
                  isSubscribed={subscribedChannelIds.includes(summary.publisher_id)}
                />
              ))
            ) : (
              // For logged-in users with no summaries
              <div className='bg-gray-900 border border-gray-800 rounded-lg p-8 text-center'>
                <p className='text-gray-300 mb-4'>
                  {`You don't have any summaries yet. ${
                    filterType === 'generated'
                      ? 'Generate summaries by entering YouTube video URLs on the home page.'
                      : ''
                  }`}
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
