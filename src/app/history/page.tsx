'use client';

// src/app/history/page.tsx - Displays user's summary history with filtering

import { useState, useEffect } from 'react';
import { useAuthStore } from '@/store/authStore';
import { supabase } from '@/lib/supabaseClient';
import SummaryCard from '@/components/SummaryCard';
import { getAnonymousGeneratedContentIds } from '@/lib/localStorage';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { ChevronDown } from 'lucide-react';

// Define interface for summary object
interface Summary {
  id: string;
  title: string;
  content_created_at: string;
  publisher_name: string;
  publisher_id: string;
  summary: string;
  content_id: string;
  tags?: string[];
  featured_names?: string[];
}

// Helper function to safely validate a summary object
function isSummary(obj: unknown): obj is Summary {
  if (!obj || typeof obj !== 'object') return false;

  const requiredProps = [
    'id',
    'title',
    'content_created_at',
    'publisher_name',
    'publisher_id',
    'summary',
    'content_id',
  ];

  return requiredProps.every(prop => prop in obj);
}

export default function HistoryPage() {
  const { user } = useAuthStore();
  const [summaries, setSummaries] = useState<Summary[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filter, setFilter] = useState<'generated' | 'all'>('all');
  const [subscriptions, setSubscriptions] = useState<Record<string, boolean>>({});

  // Fetch history data based on user and filter
  useEffect(() => {
    async function fetchHistory() {
      try {
        setLoading(true);

        if (user) {
          // Fetch the user's subscriptions to determine isSubscribed status
          const { data: userSubscriptions, error: subscriptionError } = await supabase
            .from('subscriptions')
            .select('channel_id')
            .eq('user_id', user.id);

          if (!subscriptionError && userSubscriptions) {
            // Create a map of channel_id -> true for easy lookup
            const subscriptionMap: Record<string, boolean> = {};
            userSubscriptions.forEach(sub => {
              subscriptionMap[sub.channel_id] = true;
            });
            setSubscriptions(subscriptionMap);
          }

          // For logged-in users
          if (filter === 'generated') {
            // Fetch only summaries generated by the user
            const { data, error: fetchError } = await supabase
              .from('user_generated_summaries')
              .select('summary_id, summaries(*)')
              .eq('user_id', user.id)
              .order('generated_at', { ascending: false });

            if (fetchError) {
              throw new Error(`Error fetching generated summaries: ${fetchError.message}`);
            }

            // Safely extract the summary objects from the data structure
            const formattedSummaries: Summary[] = [];
            if (data) {
              for (const item of data) {
                if (item && item.summaries && isSummary(item.summaries)) {
                  formattedSummaries.push(item.summaries);
                }
              }
            }
            setSummaries(formattedSummaries);
          } else {
            // Fetch both generated summaries and summaries from subscribed channels
            // 1. Get summaries generated by the user
            const { data: generatedData, error: generatedError } = await supabase
              .from('user_generated_summaries')
              .select('summary_id, summaries(*)')
              .eq('user_id', user.id);

            if (generatedError) {
              throw new Error(`Error fetching generated summaries: ${generatedError.message}`);
            }

            // 2. Get the user's subscribed channel IDs
            const { data: subscriptionsData, error: subscriptionsError } = await supabase
              .from('subscriptions')
              .select('channel_id')
              .eq('user_id', user.id);

            if (subscriptionsError) {
              throw new Error(`Error fetching subscriptions: ${subscriptionsError.message}`);
            }

            const channelIds = subscriptionsData?.map(sub => sub.channel_id) || [];

            // 3. Get summaries from subscribed channels if there are any
            let channelSummaries: Summary[] = [];
            if (channelIds.length > 0) {
              const { data: channelData, error: channelError } = await supabase
                .from('summaries')
                .select('*')
                .in('publisher_id', channelIds)
                .order('content_created_at', { ascending: false });

              if (channelError) {
                throw new Error(`Error fetching channel summaries: ${channelError.message}`);
              }

              // Safely convert the channel data to Summary[]
              if (channelData) {
                channelSummaries = channelData.filter(isSummary);
              }
            }

            // 4. Combine and deduplicate summaries
            // Safely extract the summary objects from generated data
            const generatedSummaries: Summary[] = [];
            if (generatedData) {
              for (const item of generatedData) {
                if (item && item.summaries && isSummary(item.summaries)) {
                  generatedSummaries.push(item.summaries);
                }
              }
            }

            const allSummaries = [...generatedSummaries, ...channelSummaries];

            // Deduplicate by id
            const uniqueSummaries = Array.from(
              new Map(allSummaries.map(item => [item.id, item])).values(),
            );

            // Sort by content_created_at descending
            uniqueSummaries.sort((a, b) => {
              const dateA = new Date(a.content_created_at || 0).getTime();
              const dateB = new Date(b.content_created_at || 0).getTime();
              return dateB - dateA;
            });

            setSummaries(uniqueSummaries);
          }
        } else {
          // For anonymous users, get summaries from localStorage
          const contentIds = getAnonymousGeneratedContentIds();

          if (contentIds.length > 0) {
            const { data, error: fetchError } = await supabase
              .from('summaries')
              .select('*')
              .in('content_id', contentIds)
              .order('content_created_at', { ascending: false });

            if (fetchError) {
              throw new Error(`Error fetching summaries: ${fetchError.message}`);
            }

            // Safely convert to Summary[]
            setSummaries(data ? data.filter(isSummary) : []);
          } else {
            setSummaries([]);
          }
        }

        setError(null);
      } catch (err) {
        console.error('Error fetching history:', err);
        setError(err instanceof Error ? err.message : 'An unknown error occurred');
        setSummaries([]);
      } finally {
        setLoading(false);
      }
    }

    fetchHistory();
  }, [user, filter]);

  if (loading) {
    return (
      <div className='p-6 max-w-7xl mx-auto'>
        {/* Skeleton loaders for summary cards */}
        <div className='grid grid-cols-1 gap-6'>
          {[...Array(3)].map((_, i) => (
            <div key={i} className='h-48 bg-gray-200 rounded-lg animate-pulse'></div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className='p-6 max-w-7xl mx-auto'>
        <div className='bg-red-50 text-red-600 p-4 rounded-md'>Error: {error}</div>
      </div>
    );
  }

  return (
    <div className='p-6 bg-gray-50 min-h-screen'>
      <div className='max-w-7xl mx-auto'>
        <div className='flex justify-between items-center mb-6'>
          <h1 className='text-2xl font-bold text-gray-900'>Your History</h1>

          {/* Filter dropdown for logged-in users */}
          {user && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant='outline' className='flex items-center'>
                  {filter === 'generated' ? 'Generated by me' : 'All summaries'}
                  <ChevronDown className='ml-2 h-4 w-4' />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                <DropdownMenuItem onClick={() => setFilter('all')}>All summaries</DropdownMenuItem>
                <DropdownMenuItem onClick={() => setFilter('generated')}>
                  Generated by me
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          )}
        </div>

        {/* Summaries list */}
        <div className='grid grid-cols-1 gap-6'>
          {summaries.length > 0 ? (
            summaries.map(summary => (
              <SummaryCard
                key={summary.id}
                title={summary.title}
                date={summary.content_created_at}
                channelName={summary.publisher_name}
                channelId={summary.publisher_id}
                isSubscribed={!!subscriptions[summary.publisher_id]}
                summary={summary.summary}
                tags={summary.tags || []}
                peopleMentioned={summary.featured_names || []}
                videoId={summary.content_id}
              />
            ))
          ) : (
            <div className='bg-white p-8 rounded-lg text-center'>
              <p className='text-gray-600'>
                {user
                  ? 'No summaries in your history yet. Try generating one!'
                  : 'No summaries in your history. Login to track your history across devices.'}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
